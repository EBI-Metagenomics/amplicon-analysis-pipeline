nextflow_pipeline {

    name "Test Workflow AMPLICON_PIPELINE"
    script "main.nf"

    test("Samplesheet amplicon-pipeline") {

        tag "samplesheet"

        when {
            params {
                input  = "${projectDir}/tests/samplesheets/test_samplesheet.csv"
                outdir = "$outputDir"
                non_insdc = true
            }
        }

        then {

            def stable_name = getAllFilesFromDir(params.outdir, relative: true, includeDir: true, ignore: ['pipeline_info/*.{html,yml}'])
            def stable_path = getAllFilesFromDir(params.outdir, ignoreFile: 'tests/.nftignore')
            def compressed_fastq = getAllFilesFromDir(params.outdir, include: ['ERR4334351/qc/*.merged.fastq.gz'])

            // the order of lines change for these files so getting the name + filesize instead
            def mseqs = getAllFilesFromDir(params.outdir, include: ['**/taxonomy-summary/**/*.mseq'])
            def mseq_strings = mseqs.collect { mseq ->
                "${mseq.name} - filesize: ${mseq.size()}"
            }
            // the order of lines change for these files so getting the name + filesize instead
            def asv_taxa = getAllFilesFromDir(params.outdir, include: ['**/asv/*asv_tax.tsv'])
            def asv_taxa_strings = asv_taxa.collect { asv_tax ->
                "${asv_tax.name} - filesize: ${asv_tax.size()}"
            }

            with(workflow) {
                assertAll(
                    { assert success }, 
                    // Test expected task success counts at potential branch points of the pipeline
                    { assert trace.succeeded().count{ task -> task.name.contains("AMPLICON_PIPELINE:READS_QC_MERGE:SEQFU_CHECK") } == 4 },
                    { assert trace.succeeded().count{ task -> task.name.contains("AMPLICON_PIPELINE:READS_QC_MERGE:FASTQSUFFIXHEADERCHECK") } == 3 },
                    { assert trace.succeeded().count{ task -> task.name.contains("AMPLICON_PIPELINE:READS_QC_MERGE:PIMENTO_GENERATEBCV") } == 2 },
                    { assert trace.succeeded().count{ task -> task.name.contains("AMPLICON_PIPELINE:READS_QC_MERGE:FASTP") } == 2 },
                    { assert trace.succeeded().count{ task -> task.name.contains("AMPLICON_PIPELINE:READS_QC_MERGE:SEQTK_SEQ") } == 2 },
                    { assert trace.succeeded().count{ task -> task.name.contains("AMPLICON_PIPELINE:RRNA_EXTRACTION:INFERNAL_CMSEARCH") } == 1 },
                    { assert trace.succeeded().count{ task -> task.name.contains("AMPLICON_PIPELINE:AMP_REGION_INFERENCE:EXTRACT_VAR_REGIONS") } == 1 },
                    { assert trace.succeeded().count{ task -> task.name.contains("AMPLICON_PIPELINE:CONCAT_PRIMER_CUTADAPT:CUTADAPT") } == 1 },
                    { assert trace.succeeded().count{ task -> task.name.contains("AMPLICON_PIPELINE:DADA2_SWF:DADA2") } == 1 },
                    // Test output of certain important files
                    { assert snapshot(
                        stable_name,
                        stable_path,
                        compressed_fastq,
                        mseq_strings,
                        asv_taxa_strings
                    ).match() }
                )
            }
        }
    }
}